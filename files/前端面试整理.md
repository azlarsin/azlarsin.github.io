title: 前端面试整理
author: azlar
date: '2017-08-10 10:22:54'
tags: []

---
前端知识梳理
<!-- desc -->
# JS
## [http://markyun.github.io/2015/Front-end-Developer-Questions/#js](http://markyun.github.io/2015/Front-end-Developer-Questions/#js)

### 介绍JavaScript的基本数据类型
- String、Number、Boolean、数组、对象、Null、Undefined、Symbol（es6）
- 基本：Undefined、Null、Boolean、Number、String

### 说说写JavaScript的基本规范？

### JavaScript原型，原型链 ? 有什么特点？
#### 原型
1. 我们可以赋值任何类型的对象到原型上，但是不能赋值原子类型的值，比如如下代码是无效的
	```js
	function Foo() {}
	Foo.prototype = 1; // 无效
	```

2. 代码
	```js
	const Calc = function () {
		this.decimalDigits = decimalDigits;
		this.tax = tax;
	};
	
	Calc.prototype = {
		add: (x, y) => x + y,
		subtract: (x, y) => x - y
	};
	
	let t = new Calc();
	
	console.log(t.tax);
	//5
	```
	
	---
	
	```js
	const Calc = function () {
		this.decimalDigits = decimalDigits;
		this.tax = tax;
	};
	
	Calc.prototype = function () {
		add = (x, y) => x + y;
		subtract = (x, y) => x - y;
		
		return {
			add,
			subtract
		}
	}();
	
	let t = new Calc();
	console.log(t.subtract(-0.5, 1));
	//-1.5
	```

#### 原型链
1. 属性在查找的时候是先查找自身的属性，如果没有再查找原型，再没有，再往上走，一直查到 Object 的原型上：

	```js
    function foo() {
        this.add = function (x, y) {
            return x + y;
        }
    }

    foo.prototype.add = function (x, y) {
        return x + y + 10;
    }

    Object.prototype.subtract = function (x, y) {
        return x - y;
    }

    var f = new foo();
    alert(f.add(1, 2)); //结果是3，而不是13
    alert(f.subtract(1, 2)); //结果是-1
	```
	
2. `hasOwnProperty()` 与防止 `hasOwnProperty()` 被占用

	```js
	//1. hasOwnProperty
	Object.prototype.bar = 1; 
	var foo = {goo: undefined};
	
	foo.bar; // 1
	'bar' in foo; // true
	
	foo.hasOwnProperty('bar');	// false
	foo.hasOwnProperty('goo');	// true
	
	//2. user define hasOwnProperty()
	var foo = {
	    hasOwnProperty: function() {
	        return false;
	    },
	    bar: 'Here be dragons'
	};
	
	foo.hasOwnProperty('bar'); // 总是返回 false
	
	// 使用{}对象的 hasOwnProperty，并将其上下为设置为foo
	{}.hasOwnProperty.call(foo, 'bar'); // true
	
	```
	
3. ``__proto__``
	
	```js
	var A = function(){};
	var a = new A();
	console.log(a.__proto__); //A {}（即构造器function A 的原型对象）
	console.log(a.__proto__ === a.constructor.prototype); //true
	console.log(a.__proto__.__proto__); //Object {}（即构造器function Object 的原型对象）
	console.log(a.__proto__.__proto__.__proto__); //null
	
	/*
	Function.prototype = {
		constructor : Function,
		__proto__ : parent prototype,
		some prototype properties: ...
	};
	*/
	```
	
4. 链式继承模型
	
	```js
	function A(x) {
		this.x = x;	
	}
	A.prototype.a = "a";
	
	function B(x, y) {
		this.y = y;
		A.call(this, x);
	}
	B.prototype.b1 = function(){
		console.log("b1");
	}
	
	B.prototype = new A();
	B.prototype.b2 = function(){
		console.log("b2");
	}
	
	B.prototype.constructor = B;
	
	var obj = new B(1,3);
	console.log(obj);
	/*
	[object Object] {
		a: "a",
		b2: function () {
			window.runnerWindow.proxyConsole.log("b2");
		},
		constructor: function B(x, y) {
			this.y = y;
			A.call(this, x);
		},
		x: 1,
		y: 3
	}
	*/
	```	
5. `new A()`分解

	```js
	var Person = function(name) {
		this.name = name;
	}
	var p = new Person();
	
	// 分解为：
	var p = {}
	p.__proto__ = Person.prototype
	Person.call(p)
	```
6. 特点
> JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。
> 
> 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，
 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。


### JavaScript有几种类型的值？（堆：原始数据类型和 栈：引用数据类型），你能画一下他们的内存图吗？
> from: [http://blog.csdn.net/lxcao/article/details/52749421](http://blog.csdn.net/lxcao/article/details/52749421)

#### 两大类

> 栈：原始数据类型（Undefined，Null，Boolean，Number、String）

> 堆：引用数据类型（对象、数组和函数）

#### 区别
两种类型的区别是：

- 存储位置不同；
- 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
- 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其
在栈中的地址，取得地址后从堆中获得实体。

#### 图
![](//blog.azlar.cc/images/frontend_interview/数据存储.png)

### Javascript如何实现继承？
class, proto chain, call。。只能想到这几个

#### 定义父类
```js
function Animal(name) {
	this.name = name || 'parent';

    this.sleep = function () {
        return this.name + ' is sleeping';
    }
}

Animal.prototype.eat = function(food) {
    return this.name + ' is eating ' + food;
};
```

##### 1. 原型链继承
核心：将父类的实例作为子类的原型

```js
function Cat() {}

Cat.prototype = new Animal();
Cat.prototype.name = 'cat';

var cat = new Cat();
console.log(cat.name);	//cat
console.log(cat.eat('fish'));	//cat is eating fish
console.log(cat.sleep());	//cat is sleeping
console.log(cat instanceof Animal); //true 
console.log(cat instanceof Cat); //true
```

特点：

	1. 非常纯粹的继承关系，实例是子类的实例，也是父类的实例
	2. 父类新增原型方法/原型属性，子类都能访问到
	3. 简单，易于实现

缺点：
	
	1. 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
	2. 无法实现多继承
	3. 来自原型对象的引用属性是所有实例共享的（详细请看附录代码： 示例1）
	4. 创建子类实例时，无法向父类构造函数传参

```js
function Animal (name) {
  // 属性
  this.name = name || 'Animal';
  // 实例方法
  this.sleep = function(){
    console.log(this.name + '正在睡觉！');
  }
  //实例引用属性
  this.features = [];
}
function Cat(name){
}
Cat.prototype = new Animal();

var tom = new Cat('Tom');
var kissy = new Cat('Kissy');

console.log(tom.name); // "Animal"
console.log(kissy.name); // "Animal"
console.log(tom.features); // []
console.log(kissy.features); // []

tom.name = 'Tom-New Name';
tom.features.push('eat');

//针对父类实例值类型成员的更改，不影响
console.log(tom.name); // "Tom-New Name"
console.log(kissy.name); // "Animal"
//针对父类实例引用类型成员的更改，会通过影响其他子类实例
console.log(tom.features); // ['eat']
console.log(kissy.features); // ['eat']

原因分析：

关键点：属性查找过程

执行tom.features.push，首先找tom对象的实例属性（找不到），
那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的
features属性中插入值。
在console.log(kissy.features); 的时候。同上，kissy实例上没有，那么去原型上找。
刚好原型上有，就直接返回，但是注意，这个原型对象中features属性值已经变化了。	
```

##### 2. 原型链继承

## self
### `call()` & `applay()`
> from: [http://uule.iteye.com/blog/1158829](http://uule.iteye.com/blog/1158829)

#### call
语法：`call([thisObj[, arg1[, arg2[,   [, .argN]]]]])`

定义：调用一个对象的一个方法，以另一个对象替换当前对象。 

说明：`call` 方法可以用来代替另一个对象调用一个方法。`call` 方法可将一个函数的对象上下文从初始的上下文改变为由 `thisObj` 指定的新对象。
如果没有提供 `thisObj` 参数，那么 *Global* 对象被用作 `thisObj`。

#### apply
语法：`apply([thisObj[, argArray]])` 

定义：应用某一对象的一个方法，用另一个对象替换当前对象。 

说明：如果 `argArray` 不是一个有效的数组或者不是 *arguments* 对象，那么将导致一个 TypeError。 
如果没有提供 `argArray` 和 `thisObj` 任何一个参数，那么 *Global* 对象将被用作 `thisObj`， 并且无法被传递任何参数。

#### code
a. 

```js
function add(x, y) { 
	console.log(x + y);
}
	
function sub(x, y) {
	console.log(x - y);
}
	
add.call(sub, 3, 1);	// 4
// add.call(sub,3,1) == add(3,1) 
```
b. 

```js
function Animal() {
    this.name = 'Animal';
    this.showName = function() {
        console.log(this.name)
    }
}
	
function Cat() {
    this.name = 'Cat';
}
	
let animal = new Animal(),
    cat = new Cat();
	
animal.showName.call(cat);	// Cat
//animal.showName.apply(cat); // Cat
```

c. 实现继承

```js
function Animal(name){
    this.name = name;
    this.showName = function(){
        console.log(this.name);
    }
}
    
function Cat(name){
    Animal.call(this, name);
}

var cat = new Cat("Black Cat");
cat.showName();	// Black Cat
```

d. 多重继承

```js
function Class10()
{
    this.showSub = function(a,b)
    {
        console.log(a - b);
    }
}

function Class11()
{
    this.showAdd = function(a,b)
    {

        console.log(a + b);
    }
}

function Class2()
{
    Class10.call(this);
    Class11.call(this);
}

let t = new Class2();

t.showAdd(1, 2);
```

### 变量提升
### 获取 scrollbar 宽高
法一：

```js
function getScrollBarWidth () {
    var inner = document.createElement('p);
    inner.style.width = "100%";
    inner.style.height = "200px";

    var outer = document.createElement('div');
    outer.style.position = "absolute";
    outer.style.top = "0px";
    outer.style.left = "0px";
    outer.style.visibility = "hidden";
    outer.style.width = "200px";
    outer.style.height = "150px";
    outer.style.overflow = "hidden";
    outer.appendChild (inner);

    document.body.appendChild (outer);
    var w1 = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    var w2 = inner.offsetWidth;
    if (w1 == w2) w2 = outer.clientWidth;

    document.body.removeChild (outer);

    return (w1 - w2);
};
```

法二：

```js
//确定 div1 已有 scrollBar 的情况下（若没有需要像法一一样生成）：

let div1 = document.getElementById("div1");

let scrollBarWidth = parseInt(div1.getBoundingClientRect().width) - parseInt(window.getComputedStyle(div1).width);

//same as
//let scrollBarWidth = div1.offsetWidth - div1.clientWidth;
```

### range(0, n) 中间缺少一个
法一：

当 n 不是很大的时候，直接对其 reduce 求和，之后再根据数学公式求和 `sum(1, ...n)`，即可。

```js
let arr = range(1, n);
let sum = arr.reduce((a, b) => a + b, 0);
let realSum = n * (n + 1) / 2;

let x = realSum - sum;
```

法二：
将 range 中所有的数字异或，之后循环 arr，与每一个异或，最后求出所求。

法三：
排序后，循环比对。

### Map vs Object
具体参考：[https://blog.azlar.cc/article/JavaScript-Object-%E4%B8%8E-Map-%E6%AF%94%E8%BE%83/](https://blog.azlar.cc/article/JavaScript-Object-%E4%B8%8E-Map-%E6%AF%94%E8%BE%83/)

此处只列出我想到的。。

1. Map 的 key 可以为任意结构，而 Object 的 key 只能为 string
2. Map 有 `size()` 可以直接获得长度，Object 需要计算。
3. 。。。


### 常用排序、复杂度


### webpack chunk + react router

### isArray
```js
function isArray(obj){
    return Object.prototype.toString.call(obj) === '[object Array]';
}

//string
function isString(str){
    return Object.prototype.toString.call(str) === '[object String]';
}

```

### `$.extend()` vs `Object.assign()`

### 文档回流与重绘
> from: [http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/](http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/)

#### 触发回流的操作
1. 调整窗口大小（Resizing the window）
2. 改变字体（Changing the font）
3. 增加或者移除样式表（Adding or removing a stylesheet）
4. 内容变化，比如用户在input框中输入文字（Content changes, such as a user typing text in
an input box）
5. 激活 CSS 伪类，比如 :hover (IE 中为兄弟结点伪类的激活)（Activation of CSS pseudo classes such as :hover (in IE the activation of the pseudo class of a sibling)）
6. 操作 class 属性（Manipulating the class attribute）
7. 脚本操作 DOM（A script manipulating the DOM）
8. 计算 offsetWidth 和 offsetHeight 属性（Calculating offsetWidth and offsetHeight）
9. 设置 style 属性的值 （Setting a property of the style attribute）

#### TBD..

### `==` vs `===`
#### `==`
```js
console.log('a' == true);
console.log('a' == false);
	
console.log(123 == true);
console.log(123 == false);
	
console.log([] == true);
console.log([] == false);	//true
	
console.log({} == true)
console.log({} == false);
	
console.log([0] == false);	//true
console.log([0] == true);	//false
	
console.log(false == null);	//false
console.log(true == null);	//false
	
console.log([] == false);
if([]) {
    console.log(2);
}
	
```
	
此处要注意与 php 的混淆：
	
```php
echo 123 == true;	//1
echo 'abc' == true;	//1
	
echo [0] == true;	//1
echo false == null;	//1
```
	
#### `if(x)` 与 `x == true` 不同
> from: [https://stackoverflow.com/questions/23061921/javascript-ifx-vs-ifx-true](https://stackoverflow.com/questions/23061921/javascript-ifx-vs-ifx-true)
> 
> if(x):
	
	+-----------------------------------------------------------------------+
	| Argument Type | Result                                                |
	|:--------------|------------------------------------------------------:|
	| Undefined     | false                                                 |
	|---------------|-------------------------------------------------------|
	| Null          | false                                                 |
	|---------------|-------------------------------------------------------|
	| Boolean       | The result equals the input argument (no conversion). |
	|---------------|-------------------------------------------------------|
	| Number        | The result is false if the argument is +0, −0, or NaN;|
	|               | otherwise the result is true.                         |
	|---------------|-------------------------------------------------------|
	| String        | The result is false if the argument is the empty      |
	|               | String (its length is zero); otherwise the result is  |
	|               | true.                                                 |
	|---------------|-------------------------------------------------------|
	| Object        | true                                                  |
	+-----------------------------------------------------------------------+

#### **文档**
	
> from: [[http://es5.github.io/#x11.9.3](http://es5.github.io/#x11.9.3)]([http://es5.github.io/#x11.9.3](http://es5.github.io/#x11.9.3))
>
> **11.9.3 The Abstract Equality Comparison Algorithm**
>
> The comparison *x* == *y*, where *x* and *y* are values, produces **true** or **false**. Such a comparison is performed as follows:

>	1. If Type(*x*) is the same as Type(*y*), then

>		1. If Type(*x*) is Undefined, return **true**.
>		2. If Type(*x*) is Null, return **true**.
>		3. If Type(*x*) is Number, then

>			1. If *x* is **NaN**, return **false**.
>			2. If *y* is **NaN**, return **false**.
>			3. If *x* is the same Number value as *y*, return **true**.
>			4. If *x* is **+0** and *y* is **−0**, return **true**.
>			5. If *x* is **−0** and *y* is **+0**, return **true**.
>			6. Return **false**.

>		4. If Type(*x*) is String, then return **true** if *x* and *y* are exactly the same sequence of characters (same length and same characters in corresponding positions). Otherwise, return **false**.
>		5. If Type(*x*) is Boolean, return **true** if *x* and *y* are both **true** or both **false**. Otherwise, return **false**.
>		6. Return **true** if *x* and *y* refer to the same object. Otherwise, return **false**.

>	2. If *x* is **null** and *y* is **undefined**, return **true**.
>	3. If *x* is **undefined** and *y* is **null**, return **true**.
>	4. If Type(*x*) is Number and Type(*y*) is String, return the result of the comparison *x* == ToNumber(*y*).
>	5. If Type(*x*) is String and Type(*y*) is Number, return the result of the comparison ToNumber(*x*) == *y*.
>	6. If Type(*x*) is Boolean, return the result of the comparison ToNumber(*x*) == *y*.
>	7. If Type(*y*) is Boolean, return the result of the comparison *x* == ToNumber(*y*).
>	8. If Type(*x*) is either String or Number and Type(*y*) is Object, return the result of the comparison *x* == ToPrimitive(*y*).
>	9. If Type(*x*) is Object and Type(*y*) is either String or Number, return the result of the comparison ToPrimitive(*x*) == *y*.
>	10. Return **false**.

> **Note 1**:		Given the above definition of equality

>	* String comparison can be forced by: **"" + a == "" + b**.
>	* Numeric comparison can be forced by: **+a == +b**.
>	* Boolean comparison can be forced by: **!a == !b**.

> **Note 2**:		The equality operators maintain the following invariants:

>	* **A != B** is equivalent to **!(A == B)**.
>	* **A == B** is equivalent to **B == A**, except in the order of evaluation of **A** and **B**.

> **Note 3**:	The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the == operator, but the two String objects would not be equal to each other.

>
> **Note 4**:	Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form.

--

> **11.9.4 The Strict Equals Operator ( === )**
>
> The production EqualityExpression : *EqualityExpression* === *RelationalExpression* is evaluated as follows:
>
> 	1. Let *lref* be the result of evaluating EqualityExpression.
> 	2. Let *lval* be GetValue(*lref*).
> 	3. Let *rref* be the result of evaluating RelationalExpression.
> 	4. Let *rval* be GetValue(*rref*).
> 	5. Return the result of performing the strict equality comparison *rval* === *lval*. (See 11.9.6)
>

--

> **11.9.5 The Strict Does-not-equal Operator ( !== ) **
>
> The production EqualityExpression : *EqualityExpression* !== *RelationalExpression* is evaluated as follows:
>
> 	1. Let *lref* be the result of evaluating EqualityExpression.
> 	2. Let *lval* be GetValue(*lref*).
> 	3. Let *rref* be the result of evaluating RelationalExpression.
> 	4. Let *rval* be GetValue(*rref*).
> 	5. Let *r* be the result of performing strict equality comparison *rval* === *lval*. (See 11.9.6)
> 	6. If *r* is **true**, return **false**. Otherwise, return **true**.
>

--

> **11.9.6 The Strict Equality Comparison Algorithm**
>
> The comparison *x* === *y*, where *x* and *y* are values, produces **true** or **false**. Such a comparison is performed as follows:
>
> 	1. If Type(*x*) is different from Type(*y*), return **false**.
> 	2. If Type(*x*) is Undefined, return **true**.
> 	3. If Type(*x*) is Null, return **true**.
> 	4. If Type(*x*) is Number, then
> 		1. If *x* is **NaN**, return **false**.
> 		2. If *y* is **NaN**, return **false**.
> 		3. If *x* is the same Number value as *y*, return **true**.
> 		4. If *x* is **+0** and *y* is **−0**, return **true**.
> 		5. If *x* is **−0** and *y* is **+0**, return **true**.
> 		6. Return **false**.
>
> 	5. If Type(*x*) is String, then return **true** if *x* and *y* are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return **false**.
>
> 	6. If Type(*x*) is Boolean, return **true** if *x* and *y* are both **true** or both **false**; otherwise, return **false**.
>
> 	7. Return **true** if *x* and *y* refer to the same object. Otherwise, return **false**.
>
>
> **Note**:	This algorithm differs from the [SameValue Algorithm (9.12)](http://es5.github.io/#x9.12) in its treatment of signed zeroes and NaNs.
 