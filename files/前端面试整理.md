title: 前端面试整理
author: azlar
date: '2017-08-10 10:22:54'
tags: []

<hr />-
前端知识梳理
<!<hr /> desc <hr />>
# JS
## [http://markyun.github.io/2015/Front-end-Developer-Questions/#js](http://markyun.github.io/2015/Front-end-Developer-Questions/#js)

### 介绍JavaScript的基本数据类型
- String、Number、Boolean、数组、对象、Null、Undefined、Symbol（es6）
- 基本：Undefined、Null、Boolean、Number、String

### 说说写JavaScript的基本规范？

### JavaScript原型，原型链 ? 有什么特点？
#### 原型
1. 我们可以赋值任何类型的对象到原型上，但是不能赋值原子类型的值，比如如下代码是无效的
	```js
	function Foo() {}
	Foo.prototype = 1; // 无效
	```

2. 代码
	```js
	const Calc = function () {
		this.decimalDigits = decimalDigits;
		this.tax = tax;
	};
	
	Calc.prototype = {
		add: (x, y) => x + y,
		subtract: (x, y) => x - y
	};
	
	let t = new Calc();
	
	console.log(t.tax);
	//5
	```
	
	<hr />-
	
	```js
	const Calc = function () {
		this.decimalDigits = decimalDigits;
		this.tax = tax;
	};
	
	Calc.prototype = function () {
		add = (x, y) => x + y;
		subtract = (x, y) => x - y;
		
		return {
			add,
			subtract
		}
	}();
	
	let t = new Calc();
	console.log(t.subtract(-0.5, 1));
	//-1.5
	```

#### 原型链
1. 属性在查找的时候是先查找自身的属性，如果没有再查找原型，再没有，再往上走，一直查到 Object 的原型上：

	```js
    function foo() {
        this.add = function (x, y) {
            return x + y;
        }
    }

    foo.prototype.add = function (x, y) {
        return x + y + 10;
    }

    Object.prototype.subtract = function (x, y) {
        return x - y;
    }

    var f = new foo();
    alert(f.add(1, 2)); //结果是3，而不是13
    alert(f.subtract(1, 2)); //结果是-1
	```
	
2. `hasOwnProperty()` 与防止 `hasOwnProperty()` 被占用

	```js
	//1. hasOwnProperty
	Object.prototype.bar = 1; 
	var foo = {goo: undefined};
	
	foo.bar; // 1
	'bar' in foo; // true
	
	foo.hasOwnProperty('bar');	// false
	foo.hasOwnProperty('goo');	// true
	
	//2. user define hasOwnProperty()
	var foo = {
	    hasOwnProperty: function() {
	        return false;
	    },
	    bar: 'Here be dragons'
	};
	
	foo.hasOwnProperty('bar'); // 总是返回 false
	
	// 使用{}对象的 hasOwnProperty，并将其上下为设置为foo
	{}.hasOwnProperty.call(foo, 'bar'); // true
	
	```
	
3. ``__proto__``
	
	```js
	var A = function(){};
	var a = new A();
	console.log(a.__proto__); //A {}（即构造器function A 的原型对象）
	console.log(a.__proto__ === a.constructor.prototype); //true
	console.log(a.__proto__.__proto__); //Object {}（即构造器function Object 的原型对象）
	console.log(a.__proto__.__proto__.__proto__); //null
	
	/*
	Function.prototype = {
		constructor : Function,
		__proto__ : parent prototype,
		some prototype properties: ...
	};
	*/
	```
	
4. 链式继承模型
	
	```js
	function A(x) {
		this.x = x;	
	}
	A.prototype.a = "a";
	
	function B(x, y) {
		this.y = y;
		A.call(this, x);
	}
	B.prototype.b1 = function(){
		console.log("b1");
	}
	
	B.prototype = new A();
	B.prototype.b2 = function(){
		console.log("b2");
	}
	
	B.prototype.constructor = B;
	
	var obj = new B(1,3);
	console.log(obj);
	/*
	[object Object] {
		a: "a",
		b2: function () {
			window.runnerWindow.proxyConsole.log("b2");
		},
		constructor: function B(x, y) {
			this.y = y;
			A.call(this, x);
		},
		x: 1,
		y: 3
	}
	*/
	```	
5. `new A()`分解

	```js
	var Person = function(name) {
		this.name = name;
	}
	var p = new Person();
	
	// 分解为：
	var p = {}
	p.__proto__ = Person.prototype
	Person.call(p)
	```
6. 特点
> JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。
> 
> 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，
 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。


### JavaScript有几种类型的值？（堆：原始数据类型和 栈：引用数据类型），你能画一下他们的内存图吗？
> from: [http://blog.csdn.net/lxcao/article/details/52749421](http://blog.csdn.net/lxcao/article/details/52749421)

#### 两大类

> 栈：原始数据类型（Undefined，Null，Boolean，Number、String）

> 堆：引用数据类型（对象、数组和函数）

#### 区别
两种类型的区别是：

- 存储位置不同；
- 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
- 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其
在栈中的地址，取得地址后从堆中获得实体。

#### 图
![](//blog.azlar.cc/images/frontend_interview/数据存储.png)

### Javascript如何实现继承？
class, proto chain, call。。只能想到这几个

摘抄一篇：

> from: [http://www.cnblogs.com/humin/p/4556820.html](http://www.cnblogs.com/humin/p/4556820.html)

#### 定义父类
```js
function Animal(name) {
	this.name = name || 'parent';

    this.sleep = function () {
        return this.name + ' is sleeping';
    }
}

Animal.prototype.eat = function(food) {
    return this.name + ' is eating ' + food;
};
```

##### 1. 原型链继承
核心：**将父类的实例作为子类的原型**

```js
function Cat() {}

Cat.prototype = new Animal();
Cat.prototype.name = 'cat';

var cat = new Cat();
console.log(cat.name);	//cat
console.log(cat.eat('fish'));	//cat is eating fish
console.log(cat.sleep());	//cat is sleeping
console.log(cat instanceof Animal); //true 
console.log(cat instanceof Cat); //true
```

特点：

	1. 非常纯粹的继承关系，实例是子类的实例，也是父类的实例
	2. 父类新增原型方法/原型属性，子类都能访问到
	3. 简单，易于实现

缺点：
	
	1. 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
	2. 无法实现多继承
	3. 来自原型对象的引用属性是所有实例共享的（详细请看附录代码：示例1）
	4. 创建子类实例时，无法向父类构造函数传参

推荐指数：★★（3、4两大致命缺陷）


示例1:

```js
function Animal (name) {
  // 属性
  this.name = name || 'Animal';
  // 实例方法
  this.sleep = function(){
    console.log(this.name + '正在睡觉！');
  }
  //实例引用属性
  this.features = [];
}
function Cat(name){
}
Cat.prototype = new Animal();

var tom = new Cat('Tom');
var kissy = new Cat('Kissy');

console.log(tom.name); // "Animal"
console.log(kissy.name); // "Animal"
console.log(tom.features); // []
console.log(kissy.features); // []

tom.name = 'Tom-New Name';
tom.features.push('eat');

//针对父类实例值类型成员的更改，不影响
console.log(tom.name); // "Tom-New Name"
console.log(kissy.name); // "Animal"
//针对父类实例引用类型成员的更改，会通过影响其他子类实例
console.log(tom.features); // ['eat']
console.log(kissy.features); // ['eat']
```
原因分析：

关键点：属性查找过程

执行tom.features.push，首先找tom对象的实例属性（找不到），
那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的
features属性中插入值。
在console.log(kissy.features); 的时候。同上，kissy实例上没有，那么去原型上找。
刚好原型上有，就直接返回，但是注意，这个原型对象中features属性值已经变化了。

##### 2. 构造继承
核心：**使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）**

```js
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
```

特点：

	1. 解决了1中，子类实例共享父类引用属性的问题
	2. 创建子类实例时，可以向父类传递参数
	3. 可以实现多继承（call多个父类对象）

缺点：

	1. 实例并不是父类的实例，只是子类的实例
	2. 只能继承父类的实例属性和方法，不能继承原型属性/方法
	3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
	
推荐指数：★★（缺点3）


##### 3. 实例继承
核心：**为父类实例添加新特性，作为子类实例返回**

```js
function Cat(name){
  var instance = new Animal();
  instance.name = name || 'Tom';
  return instance;
}

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // false
```

特点：

	1. 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果

缺点：

	1. 实例是父类的实例，不是子类的实例
	2. 不支持多继承

推荐指数：★★

##### 4. 拷贝继承
```js
function Cat(name){
  var animal = new Animal();
  for(var p in animal){
    Cat.prototype[p] = animal[p];
  }
  Cat.prototype.name = name || 'Tom';
}

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
```

特点：

	1. 支持多继承

缺点：

	1. 效率较低，内存占用高（因为要拷贝父类的属性）
	2. 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）


推荐指数：★（缺点1）


##### 5. 组合继承
核心：**通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用**

```js
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
Cat.prototype = new Animal();

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // true
```

特点：
	
	1. 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法
	2. 既是子类的实例，也是父类的实例
	3. 不存在引用属性共享问题
	4. 可传参
	5. 函数可复用

缺点：

	1. 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）

推荐指数：★★★★（仅仅多消耗了一点内存）

		
##### 6. 寄生组合继承
核心：**通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点**

```js
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
(function(){
  // 创建一个没有实例方法的类
  var Super = function(){};
  Super.prototype = Animal.prototype;
  //将实例作为子类的原型
  Cat.prototype = new Super();
})();

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); //true
```
**堪称完美**

缺点：
	
	1. 实现较为复杂

推荐指数：★★★★（实现复杂，扣掉一颗星）



### Javascript创建对象的几种方式？
```js
let oa = {};


let ob = new Object();


function ObjectC() {}

let oc = new ObjectC();
oc.a = 123;
oc.foo = () => {};


function ObjectD(name, sex, something = '') {
	this.name = name;
	this.sex = sex;
	this.something = something || null;
	
	this.do = function () {
		console.log(this.name + "is doing " + this.something);
	}
}

let od = new ObjectD("azlar", 1, "homework");
od.do();

function ObjectE() {}
ObjectE.prototype.name = "azlar";
ObjectE.prototype.sex = 1;

let oe = new ObjectE();


//other 混合模式(原型和构造函数)
function Car(name,price){  
  this.name=name;  
  this.price=price;   
}  
 Car.prototype.sell=function(){  
   alert("我是"+this.name+"，我现在卖"+this.price+"万元");  
  }  
  
var camry =new Car("凯美瑞",27);  
camry.sell();   

//动态原型的方式(可以看作是混合模式的一种特例)
function Car(name,price){  
  this.name=name;  
  this.price=price;   
  if(typeof Car.sell=="undefined"){  
   Car.prototype.sell=function(){  
    alert("我是"+this.name+"，我现在卖"+this.price+"万元");  
   }  
 Car.sell=true;  
  }  
}  
  
var camry =new Car("凯美瑞",27);  
camry.sell();  

```

### Javascript作用链域?
#### 作用域
js 没有块级作用域，只有函数作用域。

另：js 中未使用 `var` 声明的变量都是全局变量，且可被 `delete` 删除：

```js
s = 123;
var a = 123;
delete s;

console.log(s, a);
//ReferenceError: s is not defined
```

#### 作用域链
```
name="lwy";
function t(){
    var name="tlwy";
    function s(){
        var name="slwy";
        console.log(name);
    }
    function ss(){
        console.log(name);
    }
    s();
    ss();
}
t();
console.log(name);

//slwy
//tlwy
//lwy
```

> from: [https://community.risingstack.com/explaining-javascript-closure-scope-chain-examples/](https://community.risingstack.com/explaining-javascript-closure-scope-chain-examples/)
> 
> **When a variable is used, the program traverses the scope chain until it finds an entry for that variable. Redeclaring a variable or passing it into a function is a way of separating it from its previous existence in the scope chain.**
> 
> ```js
> var str1 = 'hello';  
> //Redeclaring the variable
> var str2 = str1;  
> str1 = 'goodbye';  
> //Redeclaring the variable has separated it from its original reference
> console.log(str2);//hello
> 
> var str1 = 'hello';  
> var printVar = function(v){  
>     return function(){
>         console.log(v);
>     };
> };
> //Passing in variable into a function
> var printHello = printVar(str1);
> str1 = 'goodbye';  
> //Passing the variable into a function has saved it in the function's scope
> printHello();//hello
> ```
> 

一些例子：

```js
//Even though the name of the variable is the same, we are using the
//value that is passed into the function, not the value that keeps incrementing
var logI = function(i){  
    return function(){
        console.log(i);
    };
};

for (var i = 0; i < 10; i++){  
    setTimeout(logI(i), 1000);
}

//or

var logI = function(i){
    // return function(){
        console.log(i);
    // };
};

for (var i = 0; i < 10; i++){
    setTimeout(logI.bind(this, i), 1000);
}


//result: 0 1 2 3 4 5 6 7 8 9
```

> from: [http://ryanmorr.com/understanding-scope-and-context-in-javascript/](http://ryanmorr.com/understanding-scope-and-context-in-javascript/)
> 
> ```js
> function first() {
> 	second();
> 		function second() {
> 			third();
>        	function third() {
>             fourth();
>             function fourth() {
>                 // do something
>             }
>         }
>     }   
> }
> first();
> ```
> 
> Running the preceding code will result in the nested functions being executed all the way down to the `fourth` function. At this point the scope chain would be, from top to bottom: fourth, third, second, first, global. The `fourth` function would have access to global variables and any variables defined within the `first`, `second`, and `third` functions as well as the functions themselves.

> Name conflicts amongst variables between different execution contexts are resolved by climbing up the scope chain, moving locally to globally. This means that local variables with the same name as variables higher up the scope chain take precedence.

> To put it simply, each time you attempt to access a variable within a function’s execution context, the look-up process will always begin with its own variable object. If the identifier is not found in the variable object, the search continues into the scope chain. It will climb up the scope chain examining the variable object of every execution context looking for a match to the variable name.




### 谈谈This对象的理解。
> arrow function: Until arrow functions, every new function defined its own this value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.).
> 
> 另：
> 
> 1. 有对象就指向调用对象
> 2. 没调用对象就指向全局对象
> 3. 用 new 构造就指向新对象
> 4. 通过 apply 或 call 或 bind 来改变 this 的指向

### eval是做什么的？
类似与 linux 的 exec，将字符串作为代码执行。

缺点：

1. 可读性非常差
2. 不好再做优化和编译
3. 会轻微增加性能消耗
4. 不安全，比如 eval input 的值

偶尔也可以用一下，比如写一些需要使用动态变量替换的复杂式时。

### 什么是window对象? 什么是document对象?
window 是一个顶层对象，即当前窗口。

document 对象是 window(frames) 的一个属性，包含 HTML 在内的需渲染的内容。

详细可以看下这里：[https://stackoverflow.com/questions/9895202/what-is-the-difference-between-window-screen-and-document-in-javascript](https://stackoverflow.com/questions/9895202/what-is-the-difference-between-window-screen-and-document-in-javascript)


### null，undefined的区别？
*null* 表示一个变量的值，表示 `no value`。

*undefined* 表示未声明，或未被赋值（declared）。

```js
var a;

console.log(a)	//undefined
console.log(typeof a)	//undefined
```

```js
var a = (undefined = 'abc');
console.log(a);

//abc
//当代码处于 'use strict' 严格模式时，undefined 变为只读，会报错。
//null = 'abc'; =>	ReferenceError: Invalid left-hand side in assignment
```

### 写一个通用的事件侦听器函数(机试题)。
```js
//todo
```

### ["1", "2", "3"].map(parseInt) 答案是多少？
```js
["1", "2", "3"].map(parseInt);

//=>

["1", "2", "3"].map((v, index) => parseInt(v, index));

/*
parseInt("1", 0);
parseInt("2", 1);
parseInt("3", 2);
[0]=parseInt(“1”,0);	//1*100=1*1=1

[1]=parseInt(“2”,1);	//radix不在2~36的返回NaN

[2]=parseInt(“3”,2);	//二进制数没有3，只有0 1 ，所以NaN 
*/
```

### Javascript创建对象的几种方式？
### Javascript创建对象的几种方式？
### Javascript创建对象的几种方式？
### Javascript创建对象的几种方式？
### Javascript创建对象的几种方式？
### Javascript创建对象的几种方式？

## self
### `call()` & `applay()`
> from: [http://uule.iteye.com/blog/1158829](http://uule.iteye.com/blog/1158829)

#### call
语法：`call([thisObj[, arg1[, arg2[,   [, .argN]]]]])`

定义：调用一个对象的一个方法，以另一个对象替换当前对象。 

说明：`call` 方法可以用来代替另一个对象调用一个方法。`call` 方法可将一个函数的对象上下文从初始的上下文改变为由 `thisObj` 指定的新对象。
如果没有提供 `thisObj` 参数，那么 *Global* 对象被用作 `thisObj`。

#### apply
语法：`apply([thisObj[, argArray]])` 

定义：应用某一对象的一个方法，用另一个对象替换当前对象。 

说明：如果 `argArray` 不是一个有效的数组或者不是 *arguments* 对象，那么将导致一个 TypeError。 
如果没有提供 `argArray` 和 `thisObj` 任何一个参数，那么 *Global* 对象将被用作 `thisObj`， 并且无法被传递任何参数。

#### code
a. 

```js
function add(x, y) { 
	console.log(x + y);
}
	
function sub(x, y) {
	console.log(x - y);
}
	
add.call(sub, 3, 1);	// 4
// add.call(sub,3,1) == add(3,1) 
```
b. 

```js
function Animal() {
    this.name = 'Animal';
    this.showName = function() {
        console.log(this.name)
    }
}
	
function Cat() {
    this.name = 'Cat';
}
	
let animal = new Animal(),
    cat = new Cat();
	
animal.showName.call(cat);	// Cat
//animal.showName.apply(cat); // Cat
```

c. 实现继承

```js
function Animal(name){
    this.name = name;
    this.showName = function(){
        console.log(this.name);
    }
}
    
function Cat(name){
    Animal.call(this, name);
}

var cat = new Cat("Black Cat");
cat.showName();	// Black Cat
```

d. 多重继承

```js
function Class10()
{
    this.showSub = function(a,b)
    {
        console.log(a - b);
    }
}

function Class11()
{
    this.showAdd = function(a,b)
    {

        console.log(a + b);
    }
}

function Class2()
{
    Class10.call(this);
    Class11.call(this);
}

let t = new Class2();

t.showAdd(1, 2);
```

### 变量提升
### 获取 scrollbar 宽高
法一：

```js
function getScrollBarWidth () {
    var inner = document.createElement('p);
    inner.style.width = "100%";
    inner.style.height = "200px";

    var outer = document.createElement('div');
    outer.style.position = "absolute";
    outer.style.top = "0px";
    outer.style.left = "0px";
    outer.style.visibility = "hidden";
    outer.style.width = "200px";
    outer.style.height = "150px";
    outer.style.overflow = "hidden";
    outer.appendChild (inner);

    document.body.appendChild (outer);
    var w1 = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    var w2 = inner.offsetWidth;
    if (w1 == w2) w2 = outer.clientWidth;

    document.body.removeChild (outer);

    return (w1 - w2);
};
```

法二：

```js
//确定 div1 已有 scrollBar 的情况下（若没有需要像法一一样生成）：

let div1 = document.getElementById("div1");

let scrollBarWidth = parseInt(div1.getBoundingClientRect().width) - parseInt(window.getComputedStyle(div1).width);

//same as
//let scrollBarWidth = div1.offsetWidth - div1.clientWidth;
```

### range(0, n) 中间缺少一个
法一：

当 n 不是很大的时候，直接对其 reduce 求和，之后再根据数学公式求和 `sum(1, ...n)`，即可。

```js
let arr = range(1, n);
let sum = arr.reduce((a, b) => a + b, 0);
let realSum = n * (n + 1) / 2;

let x = realSum - sum;
```

法二：
将 range 中所有的数字异或，之后循环 arr，与每一个异或，最后求出所求。

法三：
排序后，循环比对。

### Map vs Object
具体参考：[https://blog.azlar.cc/article/JavaScript-Object-%E4%B8%8E-Map-%E6%AF%94%E8%BE%83/](https://blog.azlar.cc/article/JavaScript-Object-%E4%B8%8E-Map-%E6%AF%94%E8%BE%83/)

此处只列出我想到的。。

1. Map 的 key 可以为任意结构，而 Object 的 key 只能为 string
2. Map 有 `size()` 可以直接获得长度，Object 需要计算。
3. 。。。


### 常用排序、复杂度
冒泡、希尔、快排、插入排序

#### 冒泡
```js
function bubbleSort(array){
	var len = array.length,i,j, d;
	for(i=len;i<hr />;){
		for(j=0; j<i; j++){
			var z = j+1;
			if(array[j] > array[z]){
				d = array[j];
				array[j] = array[z];
				array[z] = d;
			}
		}
	}
	return array;
}

```

#### 快速排序
基本思想：

1. 选择一个基准元素,通常选择第一个元素或者最后一个元素,
2. 通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。
3. 此时基准元素在其排好序后的正确位置
4. 然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。

```js
function quickSort(array){
	if(array.length == 0){
		return array;
	}
	var i = 0;
	var j = array.length - 1;
	var Sort = function(i, j){
	
		// 结束条件
		if(i == j ){ 
			return; 
		};
		
		var key = array[i];
		var stepi = i; // 记录开始位置
		var stepj = j; // 记录结束位置
	
		while(j > i){
			// j <<<hr /><hr /><hr /><hr /><hr /><hr /><hr /> 向前查找
			if(array[j] >= key){
				j<hr />;
			}else{
				
				array[i] = array[j]
				//i++ <hr /><hr /><hr /><hr /><hr /><hr />>>向后查找
				while(j > ++i){
					if(array[i] > key){
						array[j] = array[i];
						break;
					}
					
				}
			}

		}
		
		// 如果第一个取出的 key 是最小的数
		if(stepi == i){
			Sort(++i, stepj);
			return ;
		}
		
		// 最后一个空位留给 key
		array[i] = key;
		
		
		// 递归
		Sort(stepi, i);
		Sort(j, stepj);
	}
	
	Sort(i, j);
	
	return array;
}
```

#### 插入排序
时间复杂度：O（n^2）
```js
function insertSort(array){

	var i = 1, j, step, key,
		len = array.length;
	//二分法
	var fun2f = function(a, b) {
		return Math.floor((a + b) / 2)
	}
	for(; i < len; i++){
		step = j = i;
		key = array[j];
		var b=0,e=i,
			z = fun2f(b, e)
		// while(<hr />j > -1){
		// 	if(array[j] > key){
		// 		array[j+1] = array[j];
		// 	}else{
		// 		break;
		// 	}
		// }
		while (z != b) {
			if (key < array[z]) {
				e = z;
			} else {
				b = z;
			}
			z = fun2f(b, e);
		}
		z += key < array[z] ? 0 : 1;
		array.splice(z, 0, array.splice(i, 1)[0]);
	}
	
	return array;
}
```

#### 希尔排序
```js
function shellSort(array){

	var stepArr = [1031612713, 217378076, 45806244, 9651787, 2034035, 428481, 90358, 19001, 4025, 1750, 836, 701, 301, 132, 57, 23, 10, 4, 1]; // reverse() 在维基上看到这个最优的步长 较小数组
	var i = 0;
	var stepArrLength = stepArr.length;
	var len = array.length;
	var len2 =  parseInt(len/2);
	
	for(;i < stepArrLength; i++){
		if(stepArr[i] > len2){
			continue;
		}
		stepSort(stepArr[i]);
	}
	// 排序一个步长
	function stepSort(step){
		
		//console.log(step) 使用的步长统计
		
		var i = 0, j = 0, f, tem, key;
		
		
		for(;i < step; i++){// 依次循环列
			for(j=1; step * j + i < len; j++){//依次循环每列的每行
				tem = f = step * j + i;
				key = array[f];
				while((tem-=step) >= 0){// 依次向上查找
					if(array[tem] > key){
						array[tem+step] = array[tem];
					}else{
						break;
					}
				}
				array[tem + step ] = key;
			}
		}
		
	}
	
	return array;
	
}
```

#### 选择排序
```js
function selectionSort(array){
	var len = array.length;
	var index = 0;
	var k;
	var item;
	var c;
	for(var i=0; i<len; i++){
		
		item = array[i];
		index = i;
		//寻找最小的数位置
		for(j=i+1; j<len;j++){
			if(array[j] < item){
				index = j;
				item = array[j];
			}
		}
		if(index != i){
			c = array[i];
			array[i] = array[index];
			array[index] = c;
		}
	}
	return array;
}
```



### webpack chunk + react router

### isArray
```js
function isArray(obj){
    return Object.prototype.toString.call(obj) === '[object Array]';
}

//string
function isString(str){
    return Object.prototype.toString.call(str) === '[object String]';
}

```

### `$.extend()` vs `Object.assign()`

### 文档回流与重绘
> from: [http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/](http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/)

#### 触发回流的操作
1. 调整窗口大小（Resizing the window）
2. 改变字体（Changing the font）
3. 增加或者移除样式表（Adding or removing a stylesheet）
4. 内容变化，比如用户在input框中输入文字（Content changes, such as a user typing text in
an input box）
5. 激活 CSS 伪类，比如 :hover (IE 中为兄弟结点伪类的激活)（Activation of CSS pseudo classes such as :hover (in IE the activation of the pseudo class of a sibling)）
6. 操作 class 属性（Manipulating the class attribute）
7. 脚本操作 DOM（A script manipulating the DOM）
8. 计算 offsetWidth 和 offsetHeight 属性（Calculating offsetWidth and offsetHeight）
9. 设置 style 属性的值 （Setting a property of the style attribute）

#### TBD..

### `==` vs `===`
#### `==`
```js
console.log('a' == true);
console.log('a' == false);
	
console.log(123 == true);
console.log(123 == false);
	
console.log([] == true);
console.log([] == false);	//true
	
console.log({} == true)
console.log({} == false);
	
console.log([0] == false);	//true
console.log([0] == true);	//false
	
console.log(false == null);	//false
console.log(true == null);	//false
	
console.log([] == false);	//true
if([]) {
    console.log(2);	//reached here
}

console.log(NaN == NaN);	//false
	
```
	
此处要注意与 php 的混淆：
	
```php
echo 123 == true;	//1
echo 'abc' == true;	//1
	
echo [0] == true;	//1
echo false == null;	//1
```
	
#### `if(x)` 与 `x == true` 不同
> from: [https://stackoverflow.com/questions/23061921/javascript-ifx-vs-ifx-true](https://stackoverflow.com/questions/23061921/javascript-ifx-vs-ifx-true)
> 
> if(x):
	
	+<hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr />-+
	| Argument Type | Result                                                |
	|:<hr /><hr /><hr /><hr /><hr /><hr /><hr />|<hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr />:|
	| Undefined     | false                                                 |
	|<hr /><hr /><hr /><hr /><hr /><hr /><hr />-|<hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr />-|
	| Null          | false                                                 |
	|<hr /><hr /><hr /><hr /><hr /><hr /><hr />-|<hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr />-|
	| Boolean       | The result equals the input argument (no conversion). |
	|<hr /><hr /><hr /><hr /><hr /><hr /><hr />-|<hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr />-|
	| Number        | The result is false if the argument is +0, −0, or NaN;|
	|               | otherwise the result is true.                         |
	|<hr /><hr /><hr /><hr /><hr /><hr /><hr />-|<hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr />-|
	| String        | The result is false if the argument is the empty      |
	|               | String (its length is zero); otherwise the result is  |
	|               | true.                                                 |
	|<hr /><hr /><hr /><hr /><hr /><hr /><hr />-|<hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr />-|
	| Object        | true                                                  |
	+<hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr />-+

#### **文档**
	
> from: [[http://es5.github.io/#x11.9.3](http://es5.github.io/#x11.9.3)]([http://es5.github.io/#x11.9.3](http://es5.github.io/#x11.9.3))
>
> **11.9.3 The Abstract Equality Comparison Algorithm**
>
> The comparison *x* == *y*, where *x* and *y* are values, produces **true** or **false**. Such a comparison is performed as follows:

> 1. If Type(*x*) is the same as Type(*y*), then

>	1. If Type(*x*) is Undefined, return **true**.
>	2. If Type(*x*) is Null, return **true**.
>	3. If Type(*x*) is Number, then

>		1. If *x* is **NaN**, return **false**.
>		2. If *y* is **NaN**, return **false**.
>		3. If *x* is the same Number value as *y*, return **true**.
>		4. If *x* is **+0** and *y* is **−0**, return **true**.
>		5. If *x* is **−0** and *y* is **+0**, return **true**.
>		6. Return **false**.

>	4. If Type(*x*) is String, then return **true** if *x* and *y* are exactly the same sequence of characters (same length and same characters in corresponding positions). Otherwise, return **false**.
>	5. If Type(*x*) is Boolean, return **true** if *x* and *y* are both **true** or both **false**. Otherwise, return **false**.
>	6. Return **true** if *x* and *y* refer to the same object. Otherwise, return **false**.

> 2. If *x* is **null** and *y* is **undefined**, return **true**.
> 3. If *x* is **undefined** and *y* is **null**, return **true**.
> 4. If Type(*x*) is Number and Type(*y*) is String, return the result of the comparison *x* == ToNumber(*y*).
> 5. If Type(*x*) is String and Type(*y*) is Number, return the result of the comparison ToNumber(*x*) == *y*.
> 6. If Type(*x*) is Boolean, return the result of the comparison ToNumber(*x*) == *y*.
> 7. If Type(*y*) is Boolean, return the result of the comparison *x* == ToNumber(*y*).
> 8. If Type(*x*) is either String or Number and Type(*y*) is Object, return the result of the comparison *x* == ToPrimitive(*y*).
> 9. If Type(*x*) is Object and Type(*y*) is either String or Number, return the result of the comparison ToPrimitive(*x*) == *y*.
> 10. Return **false**.

> **Note 1**:		Given the above definition of equality

>	* String comparison can be forced by: **"" + a == "" + b**.
>	* Numeric comparison can be forced by: **+a == +b**.
>	* Boolean comparison can be forced by: **!a == !b**.

> **Note 2**:		The equality operators maintain the following invariants:

>	* **A != B** is equivalent to **!(A == B)**.
>	* **A == B** is equivalent to **B == A**, except in the order of evaluation of **A** and **B**.

> **Note 3**:	The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the == operator, but the two String objects would not be equal to each other.
>
> **Note 4**:	Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form.

<hr />

> **11.9.4 The Strict Equals Operator ( === )**
>
> The production EqualityExpression : *EqualityExpression* === *RelationalExpression* is evaluated as follows:
>
> 1. Let *lref* be the result of evaluating EqualityExpression.
> 2. Let *lval* be GetValue(*lref*).
> 3. Let *rref* be the result of evaluating RelationalExpression.
> 4. Let *rval* be GetValue(*rref*).
> 5. Return the result of performing the strict equality comparison *rval* === *lval*. (See 11.9.6)
>

<hr />

> **11.9.5 The Strict Does-not-equal Operator ( !== ) **
>
> The production EqualityExpression : *EqualityExpression* !== *RelationalExpression* is evaluated as follows:
>
> 1. Let *lref* be the result of evaluating EqualityExpression.
> 2. Let *lval* be GetValue(*lref*).
> 3. Let *rref* be the result of evaluating RelationalExpression.
> 4. Let *rval* be GetValue(*rref*).
> 5. Let *r* be the result of performing strict equality comparison *rval* === *lval*. (See 11.9.6)
> 6. If *r* is **true**, return **false**. Otherwise, return **true**.
>

<hr />

> **11.9.6 The Strict Equality Comparison Algorithm**
>
> The comparison *x* === *y*, where *x* and *y* are values, produces **true** or **false**. Such a comparison is performed as follows:
>
> 1. If Type(*x*) is different from Type(*y*), return **false**.
> 2. If Type(*x*) is Undefined, return **true**.
> 3. If Type(*x*) is Null, return **true**.
> 4. If Type(*x*) is Number, then
> 	1. If *x* is **NaN**, return **false**.
> 	2. If *y* is **NaN**, return **false**.
> 	3. If *x* is the same Number value as *y*, return **true**.
> 	4. If *x* is **+0** and *y* is **−0**, return **true**.
> 	5. If *x* is **−0** and *y* is **+0**, return **true**.
> 	6. Return **false**.
>
> 5. If Type(*x*) is String, then return **true** if *x* and *y* are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return **false**.
>
> 6. If Type(*x*) is Boolean, return **true** if *x* and *y* are both **true** or both **false**; otherwise, return **false**.
>
> 7. Return **true** if *x* and *y* refer to the same object. Otherwise, return **false**.
>
>
> **Note**:	This algorithm differs from the [SameValue Algorithm (9.12)](http://es5.github.io/#x9.12) in its treatment of signed zeroes and NaNs.

  
### BFC

### 0.1 + 0.2
```js
console.log(0.1 + 0.2);
//0.30000000000000004
```

一种解决方案：[math.js](http://mathjs.org/)

另：

> from: [https://www.quora.com/Why-is-0-1+0-2-not-equal-to-0-3-in-most-programming-languages](https://www.quora.com/Why-is-0-1+0-2-not-equal-to-0-3-in-most-programming-languages) & [https://www.reddit.com/r/javascript/comments/2scikz/eli5_why_is_this_true_01_02_030000000000000004/](https://www.reddit.com/r/javascript/comments/2scikz/eli5_why_is_this_true_01_02_030000000000000004/)
> 
> **You don't use equality to compare decimals.**
> 
> Computers use a certain representation to describe decimals. You can google 'floating point representation' to find out more about it, but the idea briefly is that decimals are represented as some value multiplied to a certain power of 2. So 0.75 for example is 3*(2)^-2. However, 0.1 (as is the case for most numbers) doesn't have an accurate representation, and its representation will be that of a number that's very close to 0.1 but not exactly it. It's like trying to represent 1/3 in base 10, you end up writing 0.3333333 which is close to the correct value but still not very accurate.
>
> Now, you want to compare values, you don't use equality. Instead, you compute the absolute difference and make sure that it's very small.
>
> It will be something like that:
> 
> ```js
> const EPS = 1e-6;	//1*10的-6次方。 
> 
> if(Math.abs(0.1 + 0.2 - 0.3) < EPS) {
> 	//true
> }
> ```

<hr />

> In base 10 (decimal), 1/3 is 0.333333... (the 3 repeats)
In base 2 (binary), 1/10 is 0.0001100110011... (the 0011 repeats)
Now, I want you to add 0.33... and 0.33... together. You know from fractions that the answer is 2/3, but if you MUST express it as the infinite numbers. What is more, you MUST only use 32 repeats because you run out of room if you use more. You wind up with

> ```
> 0.33333333333333333333333333333333  (rounding down)
> +0.33333333333333333333333333333333
> <hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr />
> 0.66666666666666666666666666666666
> ```
> 
> But that answer is wrong (and due to rounding the 3 earlier, we don't even have the 0.666...67 part that most people are used to).
>
> Now let's add 1/10 and 1/10 in binary (remember, 1 + 1 = 10 in binary)
>
> ```
> 0.00011001100110011 (once again we round)
> +0.00011001100110011
> <hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr />-
> 0.00110011001100110
> +0.00011001100110011
> <hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr />-
> 0.01101110111011101
> ```
> 
> With our rounding error this becomes our infamous 0.3000...4. This is exactly the same thing as rounding those 1/3 numbers in decimal.
> 


### typeof null
> from: https://stackoverflow.com/questions/18808226/why-is-typeof-null-object
> 
> ==This is a long-standing bug in JS, but one that is likely never going to be fixed. Too much code on the Web relies on the bug and thus fixing it would cause a lot more bugs!==


```js
typeof null === 'object'	//true
```
